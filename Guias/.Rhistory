install.packages("Lock5Data")
library(Lock5Data)
data("FloridaLakes")
help("FloridaLakes")
force(FloridaLakes)
View(FloridaLakes)
View(FloridaLakes)
histAlcalinidad <- hist(FloridaLakes$Alkalinity, freq = FALSE)
names(histAlcalinidad)
density(histAlcalinidad)
round(max(histAlcalinidad$density), 4)
histAlcalinidad$breaks
histAlcalinidad$counts
histAlcalinidad$mids
mean(FloridaLakes$Alkalinity)
median(FloridaLakes$Alkalinity)
round(mean(FloridaLakes$Alkalinity))
round(mean(FloridaLakes$Alkalinity), 4)
round(median(FloridaLakes$Alkalinity), 4)
round(median(FloridaLakes$Alkalinity), 5)
round(median(FloridaLakes$Alkalinity), 4)
round(mean(FloridaLakes$Alkalinity), 4, trim = 0.2)
round(mean(FloridaLakes$Alkalinity, trim = 0.2), 4)
####Pregunta 7####
round(mean(FloridaLakes$Alkalinity, trim = 0.2), 4)
cantidad <- sum(FloridaLakes$Alkalinity <= 40)
prob <- cantidad / 53
round(prob, 4)
ggplot(FloridaLakes, aes(y = Alkalinity)) +
geom_boxplot(fill = "#77DD77", color = "black") +
labs(title = "Boxplot alcalinidad", y = "Valores") +
theme_minimal()
####Pregunta 12####
library(ggplot2)
ggplot(FloridaLakes, aes(y = Alkalinity)) +
geom_boxplot(fill = "#77DD77", color = "black") +
labs(title = "Boxplot alcalinidad", y = "Valores") +
theme_minimal()
plot(density(FloridaLakes$Alkalinity))
plot(density(FloridaLakes$Alkalinity, bw = 10))
plot(density(FloridaLakes$Alkalinity, bw = 5))
plot(density(FloridaLakes$Alkalinity, bw = 3))
plot(density(FloridaLakes$Alkalinity, bw = 1))
plot(density(FloridaLakes$Alkalinity))
####GUIA 2####
library(ggplot2)
set.seed(123)
datos <- rexp(100, rate = 1)
datos <- data.frame(x= rexp(100, rate = 1))
ggplot(datos, aes(x = x)) +
stat_ecdf(geom = "step", color = "blue", size = 1.2) +
stat_function(fun = pexp, args = list(rate = 1),
color = "red", size = 1.2) +
labs(title = "Función de distribución empírica vs teórica",
x = "x", y = "F(x)") +
theme_minimal() +
theme(plot.title = element_text(hjust = 0.5)) +
scale_y_continuous(limits = c(0,1))
View(datos)
lambdaM <- 1/mean(datos$x)
datos$x
ggplot(datos, aes(x = x)) +
stat_ecdf(geom = "step", color = "blue", size = 1.2) +
stat_function(fun = pexp, args = list(rate = 1),
color = "red", size = 1.2) +
stat_function(fun = function(x) pexp(x, rate = lambdaM),
color = "darkgreen", linetype = "dashed", size = 1.2) +
labs(title = "Función de distribución empírica vs teórica",
x = "x", y = "F(x)") +
theme_minimal() +
theme(plot.title = element_text(hjust = 0.5)) +
scale_y_continuous(limits = c(0,1))
set.seed(123)
datos <- data.frame(x= rexp(10, rate = 1))
ggplot(datos, aes(x = x)) +
stat_ecdf(geom = "step", color = "blue", size = 1.2) +
stat_function(fun = pexp, args = list(rate = 1),
color = "red", size = 1.2) +
labs(title = "Función de distribución empírica vs teórica",
x = "x", y = "F(x)") +
theme_minimal() +
theme(plot.title = element_text(hjust = 0.5)) +
scale_y_continuous(limits = c(0,1))
lambdaM <- 1/mean(datos$x)
ggplot(datos, aes(x = x)) +
stat_ecdf(geom = "step", color = "blue", size = 1.2) +
stat_function(fun = pexp, args = list(rate = 1),
color = "red", size = 1.2) +
stat_function(fun = function(x) pexp(x, rate = lambdaM),
color = "darkgreen", linetype = "dashed", size = 1.2) +
labs(title = "Función de distribución empírica vs teórica",
x = "x", y = "F(x)") +
theme_minimal() +
theme(plot.title = element_text(hjust = 0.5)) +
scale_y_continuous(limits = c(0,1))
datos <- data.frame(x= rexp(1000, rate = 1))
ggplot(datos, aes(x = x)) +
stat_ecdf(geom = "step", color = "blue", size = 1.2) +
stat_function(fun = pexp, args = list(rate = 1),
color = "red", size = 1.2) +
labs(title = "Función de distribución empírica vs teórica",
x = "x", y = "F(x)") +
theme_minimal() +
theme(plot.title = element_text(hjust = 0.5)) +
scale_y_continuous(limits = c(0,1))
lambdaM <- 1/mean(datos$x)
ggplot(datos, aes(x = x)) +
stat_ecdf(geom = "step", color = "blue", size = 1.2) +
stat_function(fun = pexp, args = list(rate = 1),
color = "red", size = 1.2) +
stat_function(fun = function(x) pexp(x, rate = lambdaM),
color = "darkgreen", linetype = "dashed", size = 1.2) +
labs(title = "Función de distribución empírica vs teórica",
x = "x", y = "F(x)") +
theme_minimal() +
theme(plot.title = element_text(hjust = 0.5)) +
scale_y_continuous(limits = c(0,1))
n <- 6
theta0 <- 3
datos6 <- data.frame(x= runif(n, min= 0, max = theta0 ))
thetaM <- 2*mean(datos$x)
thetaMv <- max(datos$x)
thetaMod <- (n+1)/n * thetaMv
estimadoresM <- c()
estimadoresM <- numeric(k)
k <- 1000
estimadoresM <- numeric(k)
estimadoresMv <- numeric(k)
estimadoresMod <- numeric(k)
for(i in 1:k) {
muestra <- runif(n, min = 0, max = theta0)
estimadoresM[i] <- 2*mean(muestra)
estimadoresMv <- max(muestra)
estimadoresMod <- (n+1)/n * (max(muestra))
}
k <- 1000
estimadoresM <- numeric(k)
estimadoresMv <- numeric(k)
estimadoresMod <- numeric(k)
for(i in 1:k) {
muestra <- runif(n, min = 0, max = theta0)
estimadoresM[i] <- 2*mean(muestra)
estimadoresMv[i] <- max(muestra)
estimadoresMod[i] <- (n+1)/n * (max(muestra))
}
n <- 10
estimadoresM10 <- numeric(k)
estimadoresMv10 <- numeric(k)
estimadoresMod10 <- numeric(k)
for(i in 1:k) {
muestra <- runif(n, min = 0, max = theta0)
estimadoresM10[i] <- 2*mean(muestra)
estimadoresMv10[i] <- max(muestra)
estimadoresMod10[i] <- (n+1)/n * (max(muestra))
}
n <- 20
estimadoresM20 <- numeric(k)
estimadoresMv20 <- numeric(k)
estimadoresMod20 <- numeric(k)
for(i in 1:k) {
muestra <- runif(n, min = 0, max = theta0)
estimadoresM20[i] <- 2*mean(muestra)
estimadoresMv20[i] <- max(muestra)
estimadoresMod20[i] <- (n+1)/n * (max(muestra))
}
n <- 40
estimadoresM40 <- numeric(k)
estimadoresMv40 <- numeric(k)
estimadoresMod40 <- numeric(k)
for(i in 1:k) {
muestra <- runif(n, min = 0, max = theta0)
estimadoresM40[i] <- 2*mean(muestra)
estimadoresMv40[i] <- max(muestra)
estimadoresMod40[i] <- (n+1)/n * (max(muestra))
}
n <- 80
estimadoresM80 <- numeric(k)
estimadoresMv80 <- numeric(k)
estimadoresMod80 <- numeric(k)
for(i in 1:k) {
muestra <- runif(n, min = 0, max = theta0)
estimadoresM80[i] <- 2*mean(muestra)
estimadoresMv80[i] <- max(muestra)
estimadoresMod80[i] <- (n+1)/n * (max(muestra))
}
n <- 200
estimadoresM200 <- numeric(k)
estimadoresMv200 <- numeric(k)
estimadoresMod200 <- numeric(k)
for(i in 1:k) {
muestra <- runif(n, min = 0, max = theta0)
estimadoresM200[i] <- 2*mean(muestra)
estimadoresMv200[i] <- max(muestra)
estimadoresMod200[i] <- (n+1)/n * (max(muestra))
}
theta0 <- 3
k <- 1000
ns <- c(6, 10, 20, 40, 80, 200)
# Lista para guardar resultados
resultados <- list()
for (n in ns) {
simulaciones <- replicate(k, {
muestra <- runif(n, min = 0, max = theta0)
c(MV  = max(muestra),
MOM = 2 * mean(muestra),
MOD = (n+1)/n * max(muestra))
})
# Guardar en lista con nombre del n
resultados[[paste0("n=", n)]] <- list(
theta_MV  = simulaciones["MV", ],
theta_mom = simulaciones["MOM", ],
theta_mod = simulaciones["MOD", ]
)
}
View(resultados)
View(resultados)
View(simulaciones)
ECM_resultados <- data.frame()
for (n_name in names(resultados)) {
# Extraer los vectores de cada estimador
sim <- resultados[[n_name]]
ECM_MV  <- mean((sim$theta_MV  - theta0)^2)
ECM_MOM <- mean((sim$theta_mom - theta0)^2)
ECM_MOD <- mean((sim$theta_mod - theta0)^2)
# Guardar en data frame
ECM_resultados <- rbind(ECM_resultados,
data.frame(n = n_name,
Estimador = c("EMV", "Momento", "Modificado"),
ECM = c(ECM_MV, ECM_MOM, ECM_MOD)))
}
View(ECM_resultados)
library(tidyr)
install.packages("dplyr")
library(tidyr)
# Preparar datos para boxplot
df_EMV <- lapply(names(resultados), function(n_name) {
data.frame(
n = as.numeric(sub("n=", "", n_name)),
EMV = resultados[[n_name]]$theta_MV
)
}) %>%
bind_rows()
theta0 <- 3
# Boxplot con línea horizontal en theta0
ggplot(df_EMV, aes(x = factor(n), y = EMV)) +
geom_boxplot(fill = "lightblue", color = "blue") +
geom_hline(yintercept = theta0, color = "red", linetype = "dashed", size = 1) +
labs(title = "Boxplots de EMV vs tamaño de muestra n",
x = "Tamaño de muestra n",
y = "EMV") +
theme_minimal()
library(ggplot2)
library(tidyr)
library(tidyr)
library(ggplot2)
library(tidyr)
library(dplyr)
# Preparar datos para boxplot
df_EMV <- lapply(names(resultados), function(n_name) {
data.frame(
n = as.numeric(sub("n=", "", n_name)),
EMV = resultados[[n_name]]$theta_MV
)
}) %>%
bind_rows()
theta0 <- 3
# Boxplot con línea horizontal en theta0
ggplot(df_EMV, aes(x = factor(n), y = EMV)) +
geom_boxplot(fill = "lightblue", color = "blue") +
geom_hline(yintercept = theta0, color = "red", linetype = "dashed", size = 1) +
labs(title = "Boxplots de EMV vs tamaño de muestra n",
x = "Tamaño de muestra n",
y = "EMV") +
theme_minimal()
# Preparar datos para boxplot
df_EM <- lapply(names(resultados), function(n_name) {
data.frame(
n = as.numeric(sub("n=", "", n_name)),
EM = resultados[[n_name]]$theta_mom
)
}) %>%
bind_rows()
theta0 <- 3
# Boxplot con línea horizontal en theta0
ggplot(df_EM, aes(x = factor(n), y = EM)) +
geom_boxplot(fill = "lightblue", color = "blue") +
geom_hline(yintercept = theta0, color = "red", linetype = "dashed", size = 1) +
labs(title = "Boxplots de EM vs tamaño de muestra n",
x = "Tamaño de muestra n",
y = "EM") +
theme_minimal()
# Preparar datos para boxplot
df_EMOD <- lapply(names(resultados), function(n_name) {
data.frame(
n = as.numeric(sub("n=", "", n_name)),
EMOD = resultados[[n_name]]$theta_mod
)
}) %>%
bind_rows()
theta0 <- 3
# Boxplot con línea horizontal en theta0
ggplot(df_EMOD, aes(x = factor(n), y = EMOD)) +
geom_boxplot(fill = "lightblue", color = "blue") +
geom_hline(yintercept = theta0, color = "red", linetype = "dashed", size = 1) +
labs(title = "Boxplots de EMOD vs tamaño de muestra n",
x = "Tamaño de muestra n",
y = "EMV") +
theme_minimal()
# Asegurarse de que n sea numérico
ECM_resultados <- ECM_resultados %>%
mutate(n = as.numeric(gsub("n=", "", n)))
# Graficar
ggplot(ECM_resultados, aes(x = n, y = ECM, color = Estimador)) +
geom_line(size = 1.2) +
geom_point(size = 2) +
scale_color_manual(values = c("EMV" = "black",
"Momento" = "red",
"Modificado" = "blue")) +
labs(title = "ECM estimado de los tres estimadores vs n",
x = "Tamaño de muestra n",
y = "ECM") +
theme_minimal() +
theme(plot.title = element_text(hjust = 0.5))
setwd("C:/Users/Sebastian/Desktop/Estadistica-y-Ciencia-de-Datos/Guias")
tormentas <- read.table("tormentas.txt")
tormentas <- read.table("tormenta.txt")
View(tormentas)
prom <- mean(tormentas$V1)
S2 <- mean((tormentas$V1 - prom)^2)
alphaMomentos <- prom^2 / S2
lambdaMomentos <- prom / S2
install.packages("MASS")
library(MASS)
fit <- fitdistr(tormentas, densfun = "gamma")
fit <- fitdistr(tormentas$V1, densfun = "gamma")
View(fit)
alpha_MLE <- fit$estimate["shape"]
lambda_MLE <- fit$estimate["rate"]
alphaMomentos
alpha_MLE
lambdaMomentos
lambda_MLE
ggplot(tormenta, aes(x = V1)) +
geom_histogram(aes(y = ..density..), bins = 30, fill = "lightgray", color = "black") +
geom_density(color = "black", size = 1.2, linetype = "solid") +  # KDE no paramétrica
stat_function(fun = dgamma, args = list(shape = alphaMomentos, rate = lambdaMomentos),
color = "blue", size = 1.2, linetype = "dashed") +
stat_function(fun = dgamma, args = list(shape = alpha_MLE, rate = lambda_MLE),
color = "red", size = 1.2, linetype = "dotted") +
labs(title = "Histograma de lluvias con densidades superpuestas",
x = "Lluvia (mm)",
y = "Densidad") +
theme_minimal() +
theme(plot.title = element_text(hjust = 0.5))
ggplot(tormentas, aes(x = V1)) +
geom_histogram(aes(y = ..density..), bins = 30, fill = "lightgray", color = "black") +
geom_density(color = "black", size = 1.2, linetype = "solid") +  # KDE no paramétrica
stat_function(fun = dgamma, args = list(shape = alphaMomentos, rate = lambdaMomentos),
color = "blue", size = 1.2, linetype = "dashed") +
stat_function(fun = dgamma, args = list(shape = alpha_MLE, rate = lambda_MLE),
color = "red", size = 1.2, linetype = "dotted") +
labs(title = "Histograma de lluvias con densidades superpuestas",
x = "Lluvia (mm)",
y = "Densidad") +
theme_minimal() +
theme(plot.title = element_text(hjust = 0.5))
prob_empirica <- sum(tormentas$V1 > 20) / sum(tormentas)
sum(tormentas)
prob_empirica <- sum(tormentas$V1 > 20) / nrow(tormentas)
prob_empirica
prob_empirica <- mean(tormentas > 20)
prob_empirica
prob_MLE <- 1 - pgamma(20, shape = alpha_MLE, rate = lambda_MLE)
prob_MM <- 1 - pgamma(20, shape = alphaMomentos, rate = lambdaMomentos)
