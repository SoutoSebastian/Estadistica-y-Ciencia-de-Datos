install.packages("Lock5Data")
library(Lock5Data)
data("FloridaLakes")
help("FloridaLakes")
force(FloridaLakes)
View(FloridaLakes)
View(FloridaLakes)
histAlcalinidad <- hist(FloridaLakes$Alkalinity, freq = FALSE)
names(histAlcalinidad)
density(histAlcalinidad)
round(max(histAlcalinidad$density), 4)
histAlcalinidad$breaks
histAlcalinidad$counts
histAlcalinidad$mids
mean(FloridaLakes$Alkalinity)
median(FloridaLakes$Alkalinity)
round(mean(FloridaLakes$Alkalinity))
round(mean(FloridaLakes$Alkalinity), 4)
round(median(FloridaLakes$Alkalinity), 4)
round(median(FloridaLakes$Alkalinity), 5)
round(median(FloridaLakes$Alkalinity), 4)
round(mean(FloridaLakes$Alkalinity), 4, trim = 0.2)
round(mean(FloridaLakes$Alkalinity, trim = 0.2), 4)
####Pregunta 7####
round(mean(FloridaLakes$Alkalinity, trim = 0.2), 4)
cantidad <- sum(FloridaLakes$Alkalinity <= 40)
prob <- cantidad / 53
round(prob, 4)
ggplot(FloridaLakes, aes(y = Alkalinity)) +
geom_boxplot(fill = "#77DD77", color = "black") +
labs(title = "Boxplot alcalinidad", y = "Valores") +
theme_minimal()
####Pregunta 12####
library(ggplot2)
ggplot(FloridaLakes, aes(y = Alkalinity)) +
geom_boxplot(fill = "#77DD77", color = "black") +
labs(title = "Boxplot alcalinidad", y = "Valores") +
theme_minimal()
plot(density(FloridaLakes$Alkalinity))
plot(density(FloridaLakes$Alkalinity, bw = 10))
plot(density(FloridaLakes$Alkalinity, bw = 5))
plot(density(FloridaLakes$Alkalinity, bw = 3))
plot(density(FloridaLakes$Alkalinity, bw = 1))
plot(density(FloridaLakes$Alkalinity))
setwd("C:/Users/Sebastian/Desktop/Estadistica-y-Ciencia-de-Datos/Clases/Clase_5")
knitr::opts_chunk$set(echo = TRUE)
# COMPLETAR: cargar los datos del archivo 'buffalo.txt'
# hint ver help(scan)
buffalo <- scan("buffalo.txt", what = numeric())
# COMPLETAR: implementar núcleo rectangular
rectangular <- function(t) {
return(0.5 * as.numeric(abs(t) <= 1))
}
rectangular(1)
rectangular(-8)
# COMPLETAR: implementar núcleo gaussiano
gaussiano <- function(t) {
termino1 <- 1/sqrt(2*pi)
termino2 <- exp(-0.5*t^2)
return(termino1 * termino2)
}
# COMPLETAR: implementar núcleo de Epanechnikov
epanechnikov <- function(t) {
return (0.75*(1-t^2)*as.numeric(abs(t)<=1))
}
# COMPLETAR: función kde
kde <- function(datos, h, x_s, K) {
n <- length(datos)
f_s <- numeric(length(x_s))
for (j in seq_along(x_s)) {
# COMPLETAR: aplicar el kernel y calcular la densidad
t1 = 1/(n*h)
t2 = 0
for (i in seq_along(datos)){
t2= t2 + K((x_s[j] -datos[i])/h)
}
#f_s[j] <- sum(K((x_s[j] - datos) / h)) / (n * h)
f_s[j] = t1*t2
}
return(f_s)
}
# solo correr la celda
x_s <- seq(min(datos), max(datos), length.out = 200)
# COMPLETAR: cargar los datos del archivo 'buffalo.txt'
# hint ver help(scan)
datos <- scan("buffalo.txt", what = numeric())
# solo correr la celda
x_s <- seq(min(datos), max(datos), length.out = 200)
h_vals <- c(10, 20, 30)
colores <- c("darkgray", "gray", "lightgray")
plot(NULL, xlim = range(x_s), ylim = c(0, 0.03),
main = "KDE con núcleo Rectangular", xlab = "Nieve (pulgadas)", ylab = "Densidad")
for (i in seq_along(h_vals)) {
h <- h_vals[i]
f_s <- kde(datos, h, x_s, rectangular)
lines(x_s, f_s, col = colores[i], lwd = 2, lty = i)
}
legend("topright", legend = paste("h =", h_vals), lty = 1:3, col = colores, lwd = 2)
# Gaussiano
colores <- c("darkgray", "gray", "lightgray")
h_vals <- c(10, 20, 30)
plot(NULL, xlim = range(x_s), ylim = c(0, 0.03),
main = "KDE con núcleo Gaussiano", xlab = "Nieve (pulgadas)", ylab = "Densidad")
for (i in seq_along(h_vals)) {
h <- h_vals[i]
f_s <- kde(datos, h, x_s, gaussiano)
lines(x_s, f_s, col = colores[i], lwd = 2, lty = i)
}
legend("topright", legend = paste("h =", h_vals), lty = 1:3, col = colores, lwd = 2)
# Epanechnikov
plot(NULL, xlim = range(x_s), ylim = c(0, 0.03),
main = "KDE con núcleo Epanechnikov", xlab = "Nieve (pulgadas)", ylab = "Densidad")
for (i in seq_along(h_vals)) {
h <- h_vals[i]
f_s <- kde(datos, h, x_s, epanechnikov)
lines(x_s, f_s, col = colores[i], lwd = 2, lty = i)
}
legend("topright", legend = paste("h =", h_vals), lty = 1:3, col = colores, lwd = 2)
# COMPLETAR: usar density() con los tres kernels
d1 <- density(datos,h = 5, kernel = "rectangular")
d2 <- density(datos,h=5, kernel = "gaussian")
d3 <- density(datos,h=5, kernel = "epanechnikov")
# Graficar
plot(d1, main = "Estimaciones con density() y h=5", col = "blue", lwd = 2)
lines(d2, col = "red", lwd = 2)
lines(d3, col = "darkgreen", lwd = 2)
# Leyenda con texto más chico
legend("topleft",
legend = c("Gaussiano", "Rectangular", "Epanechnikov"),
col = c("blue", "red", "darkgreen"),
lwd = 1,
cex = 0.5)  # tamaño de texto reducido
# COMPLETAR: calcular h_silverman
n <- length(datos)
s <- sd(datos)
iqr <- IQR(datos)
h_sil <- 1.06* min(s , iqr/1.349) * n^(-1/5)
h_sil
# COMPLETAR: función de log-verosimilitud
cv_score <- function(h, datos, K) {
n <- length(datos)
score <- 0
for (i in 1:n) {
x_i <- datos[i]
x_omit <- datos[-i]
# COMPLETAR: estimar densidad dejando uno afuera
f_i <- (sum(K(x_i - x_omit)/h)) / ((n-1) * h)
score <- score + log(f_i + 1e-10) # evitar log(0)
}
return(score)
}
# Grilla de h y cálculo
h_grid <- seq(1, 50, length.out = 100)
scores <- sapply(h_grid, cv_score, datos = datos, K = gaussiano)
h_cv <- h_grid[which.max(scores)]
h_cv
# KDE con h_sil y h_cv
f_s_sil <- kde(datos, h_sil, x_s, gaussiano)
f_s_cv <- kde(datos, h_cv, x_s, gaussiano)
plot(x_s, f_s_sil, type = "l", col = "blue", lwd = 2,
main = "Densidades con h óptimo", xlab = "Nieve (pulgadas)", ylab = "Densidad")
lines(x_s, f_s_cv, col = "red", lwd = 2)
legend("topleft", legend = c("Silverman", "CV"), col = c("blue", "red"), lwd = 2)
